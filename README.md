# MYSQL
### 第xix

####　慢查询分析

1. 程序检索了超过需要的数据
    1.  查询不需要的记录：加上limit限制
    2.  多表关联返回全部列：取需要的列
    3.  总是取全部列
    4.  重复查询相同的数据:如取用户头像地址 
2. mysql是否在分析大量超过需要的数据
    1.  响应时间：分为服务时间和排队时间；
    2.  扫描的行数和返回的行数:多表查询中服务器需要扫描多行生成结果集中成一行。
    3.  扫描的行数和访问类型：
     - 全表扫描《索引扫描《范围扫描《唯一索引扫描《常数引用
     - 索引中使用where》索引覆盖扫描（using index）返回记录然后过滤》数据表返回所有数据（using where） 中过滤          
     - 相应优化：使用索引覆盖扫描，改变表结构（汇总表），重构查询。
***
####　重构查询方式       
1.  切分查询：将大查询分割为小查询。如删除数据，一次删除会锁住很多数据。
    ````
    do{
        row_affect=DELETE FROM messages WHERE create<DATE_SUB(NOW(),INTERVAL 3 MONTH)
        LIMIT 10000;
       }while row_affect>0
    ````
2.  分解查询：对每一个表进行一次单表查询，然后在应用中组合。
    -   缓存效率更高：应用或mysql缓存了某个单表查询数据，减少查询。
    -   减少锁的竞争。
    -   应用层做关联，更容易扩展。
    -   查询本身效率提升。
    -   减少冗余记录查询。
    -   相当于哈希关联
***
####　查询执行基础
1. 查询过程：
    -   客服端发送查询给mysql服务器
    -   服务器检查查询缓存，无下一步
    -   服务端进行sql解析、预处理、查询优化器生成查询执行计划
    -   mysql根据计划调用引擎查询数据
    -   返回结果
2.  客户端－服务端协议
    -   半双工协议，一方必须等待另一方传送完所有数据包    
    -   服务器会接收全部结果然后缓存（早释放查询），但当大数据时，库函数会花费大量时间和内存存储结果集（查询占用）
     
3.  查询状态
    -   Sleep:线程等待客服端发送新的请求    
    -   Query:线程正在执行查询或正在将结果发送给客户端
    -   Locked:线程等待表锁
    -   Analyzing and statistics：线程收集存储引擎统计信息，并生成查询计划
    -   Copying to tmp table：执行查询，并将结果复制到临时表（group by、排序）
    -   Sorting result：结果排序
    -   Sending data：多个状态间传送数据｜生成结果集|向客服端法送
4.  查询优化处理
    1.  语法解析器和预处理：语法解析器解析SQL语句，生成解析树，检查语句是否正确。预处理进一步检查解析树是否合法，列是否存在，名字是否有歧义，验证权限
    2.  查询优化器：动静优化
    3.  关联表优化：根据成本重构关联顺序
    4.  排序优化：成本高。小的内存排，大的分块内存排，存到磁盘中最后合并。
****
####优化器的局限性

1.  关联子查询:exists先查外表，in查内表，根据表大小选择。连接通常好于子查询
2.  union限制:限制条件无法推到内层，需要额外写。
3.  不支持松散索引：组合索引中只使用第二个，索引无效。（可以给前面列加常数值）
4.  最大值最小值优化：
    ````
       select MIN(id) from user where username='yy';
            改写
       select id from user use index(primary) where username='yy' limit 1;
    ````
5.  同一个表上查询更新：解决办法，通过多表关update
***
####查询优化提示
***
####优化特定类型的查询
1.  优化count()查询
    1.  统计列数：在空号中指定列（字段）或列的表达式。统计行数：括号内不为空。
    2.  简单优化：myisam中反转统计、空号中表达式统计同列不同值 
    3.  复杂优化：建汇总表，索引覆盖
2.  优化关联查询
    1.  确保在on或using上的列有索引，关联表第二个表上建索引足以
    2.  groupby orderby　只涉及一个列
3.  优化子查询：尽量用关联查询
4.  优化limit分页
    1.  覆盖索引查询后再做一次关联查询返回所需的列
      ````
        mysql>select id,login_time form user
            ->join(
            ->select id from user order by title
            ->limit 50,5)
            ->as lim using(id);
       ````
    2.  通过记录上一次查询的点，下一次查询时添加如where语句来避免使用offset
5.  优化sql_calc_found_rows：在分页中，该提示用于获得去掉limit后的总行数。更好的设计是每次多获取一行，存在就显示下一页。另外一中利用缓存。
6.  优化union查询：union查询建立临时表然后填充的方式。所以需要每个查询中写入限制条件。
    在不是必须消除重复行时，加上all防止对临时表做唯一性检查。
7.  使用用户自定义变量
    1.  自定义变量：
        - 自定义变量查询时，无法使用查询缓存   
        - 不能在使用常量或标识符的地方使用，如表名
        - mysql优化器某些情况下会优化掉该变量
        - :=优先级非常低，sql语句中需要括起来
    2.  优化排名语句：可以一次完成排名而无需两次计算语句
         ````    
            mysql>select id,
                ->@num=cnt as cnt,
                ->@rank=(if(@num!=@pre_num,$rank+1,$rank)),
                 ->@pre_num=@num as dummy
                from (
                select id,count(*) as cnt
                ....
                )   
         ````
    3.  更新同时返回：更新的数据存入变量中
    4.  确定取值顺序：确保赋值与查询同时发生
    
    